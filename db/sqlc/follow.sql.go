// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: follow.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFollowChef = `-- name: CreateFollowChef :one
INSERT INTO following_chef
(
    chef_id,
    usr_id
)
VALUES
(
    $1,
    $2
)
RETURNING
    id, chef_id, usr_id, created_at
`

type CreateFollowChefParams struct {
	ChefID pgtype.UUID `json:"chefId"`
	UsrID  pgtype.UUID `json:"usrId"`
}

func (q *Queries) CreateFollowChef(ctx context.Context, arg CreateFollowChefParams) (FollowingChef, error) {
	row := q.db.QueryRow(ctx, createFollowChef, arg.ChefID, arg.UsrID)
	var i FollowingChef
	err := row.Scan(
		&i.ID,
		&i.ChefID,
		&i.UsrID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteFollowChef = `-- name: DeleteFollowChef :one
DELETE FROM
    following_chef
WHERE
    chef_id = $1
AND
    usr_id = $2
RETURNING
    id, chef_id, usr_id, created_at
`

type DeleteFollowChefParams struct {
	ChefID pgtype.UUID `json:"chefId"`
	UsrID  pgtype.UUID `json:"usrId"`
}

func (q *Queries) DeleteFollowChef(ctx context.Context, arg DeleteFollowChefParams) (FollowingChef, error) {
	row := q.db.QueryRow(ctx, deleteFollowChef, arg.ChefID, arg.UsrID)
	var i FollowingChef
	err := row.Scan(
		&i.ID,
		&i.ChefID,
		&i.UsrID,
		&i.CreatedAt,
	)
	return i, err
}

const existsFollowChef = `-- name: ExistsFollowChef :one
SELECT EXISTS (
    SELECT
        id, chef_id, usr_id, created_at
    FROM
        following_chef
    WHERE
        chef_id = $1
    AND
        usr_id = $2
)
`

type ExistsFollowChefParams struct {
	ChefID pgtype.UUID `json:"chefId"`
	UsrID  pgtype.UUID `json:"usrId"`
}

func (q *Queries) ExistsFollowChef(ctx context.Context, arg ExistsFollowChefParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsFollowChef, arg.ChefID, arg.UsrID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listFollowChef = `-- name: ListFollowChef :many
SELECT
    id,
    name,
    image_url,
    profile,
    created_at,
    updated_at,
    num_recipe,
    num_follower
FROM
    chef
WHERE
    EXISTS (
        SELECT
            1
        FROM
            following_chef
        WHERE
            usr_id = $1
        AND
            chef_id = chef.id
    )
ORDER BY
    num_follower DESC
`

type ListFollowChefRow struct {
	ID          pgtype.UUID        `json:"id"`
	Name        string             `json:"name"`
	ImageUrl    pgtype.Text        `json:"imageUrl"`
	Profile     pgtype.Text        `json:"profile"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
	NumRecipe   int32              `json:"numRecipe"`
	NumFollower int32              `json:"numFollower"`
}

func (q *Queries) ListFollowChef(ctx context.Context, usrID pgtype.UUID) ([]ListFollowChefRow, error) {
	rows, err := q.db.Query(ctx, listFollowChef, usrID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFollowChefRow
	for rows.Next() {
		var i ListFollowChefRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ImageUrl,
			&i.Profile,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumRecipe,
			&i.NumFollower,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFollowChefNewRecipe = `-- name: ListFollowChefNewRecipe :many
SELECT
    id,
    chef_id,
    name,
    servings,
    image_url,
    introduction,
    created_at,
    updated_at,
    num_fav
FROM
    recipe
WHERE
    access_level = 1
AND
    EXISTS (
        SELECT
            1
        FROM
            following_chef
        WHERE
            following_chef.usr_id = $1
        AND
            following_chef.chef_id = recipe.chef_id
    )
ORDER BY
    created_at DESC
`

type ListFollowChefNewRecipeRow struct {
	ID           pgtype.UUID        `json:"id"`
	ChefID       pgtype.UUID        `json:"chefId"`
	Name         string             `json:"name"`
	Servings     int32              `json:"servings"`
	ImageUrl     pgtype.Text        `json:"imageUrl"`
	Introduction pgtype.Text        `json:"introduction"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	NumFav       int32              `json:"numFav"`
}

func (q *Queries) ListFollowChefNewRecipe(ctx context.Context, usrID pgtype.UUID) ([]ListFollowChefNewRecipeRow, error) {
	rows, err := q.db.Query(ctx, listFollowChefNewRecipe, usrID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFollowChefNewRecipeRow
	for rows.Next() {
		var i ListFollowChefNewRecipeRow
		if err := rows.Scan(
			&i.ID,
			&i.ChefID,
			&i.Name,
			&i.Servings,
			&i.ImageUrl,
			&i.Introduction,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumFav,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
