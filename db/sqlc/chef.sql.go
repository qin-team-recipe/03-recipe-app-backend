// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: chef.sql

package db

import (
	"context"

	dto "github.com/aopontann/gin-sqlc/db/dto"
	"github.com/jackc/pgx/v5/pgtype"
)

const createChef = `-- name: CreateChef :one
SELECT
    id,
    name,
    image_url,
    profile,
    link,
    created_at,
    updated_at,
    num_recipe,
    num_follower
FROM
    insert_chef($1)
`

type CreateChefRow struct {
	ID          pgtype.UUID          `json:"id"`
	Name        string               `json:"name"`
	ImageUrl    pgtype.Text          `json:"imageUrl"`
	Profile     pgtype.Text          `json:"profile"`
	Link        dto.ChefLinkArrayDto `json:"link"`
	CreatedAt   pgtype.Timestamptz   `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz   `json:"updatedAt"`
	NumRecipe   int32                `json:"numRecipe"`
	NumFollower int32                `json:"numFollower"`
}

func (q *Queries) CreateChef(ctx context.Context, data []byte) (CreateChefRow, error) {
	row := q.db.QueryRow(ctx, createChef, data)
	var i CreateChefRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ImageUrl,
		&i.Profile,
		&i.Link,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumRecipe,
		&i.NumFollower,
	)
	return i, err
}

const getChef = `-- name: GetChef :one
SELECT
    id,
    name,
    image_url,
    profile,
    link,
    created_at,
    updated_at,
    num_recipe,
    num_follower
FROM
    v_chef
WHERE
    id = $1
`

type GetChefRow struct {
	ID          pgtype.UUID          `json:"id"`
	Name        string               `json:"name"`
	ImageUrl    pgtype.Text          `json:"imageUrl"`
	Profile     pgtype.Text          `json:"profile"`
	Link        dto.ChefLinkArrayDto `json:"link"`
	CreatedAt   pgtype.Timestamptz   `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz   `json:"updatedAt"`
	NumRecipe   int32                `json:"numRecipe"`
	NumFollower int32                `json:"numFollower"`
}

func (q *Queries) GetChef(ctx context.Context, id pgtype.UUID) (GetChefRow, error) {
	row := q.db.QueryRow(ctx, getChef, id)
	var i GetChefRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ImageUrl,
		&i.Profile,
		&i.Link,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumRecipe,
		&i.NumFollower,
	)
	return i, err
}

const listFeaturedChef = `-- name: ListFeaturedChef :many
WITH
history AS (
    SELECT
        SUM(CASE WHEN is_follow THEN 1 ELSE 0 END) - SUM(CASE WHEN is_follow THEN 0 ELSE 1 END) AS score,
        chef_id
    FROM
        follow_chef_history
    WHERE
        CURRENT_TIMESTAMP - INTERVAL '3 days' <= created_at
    GROUP BY
        chef_id
)
SELECT
    history.chef_id,
    chef.name,
    chef.image_url,
    chef.num_follower,
    history.score
FROM
    history
INNER JOIN
    chef
ON
    history.chef_id = chef.id
ORDER BY
    score DESC
LIMIT $1
`

type ListFeaturedChefRow struct {
	ChefID      pgtype.UUID `json:"chefId"`
	Name        string      `json:"name"`
	ImageUrl    pgtype.Text `json:"imageUrl"`
	NumFollower int32       `json:"numFollower"`
	Score       int32       `json:"score"`
}

func (q *Queries) ListFeaturedChef(ctx context.Context, lim int32) ([]ListFeaturedChefRow, error) {
	rows, err := q.db.Query(ctx, listFeaturedChef, lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeaturedChefRow
	for rows.Next() {
		var i ListFeaturedChefRow
		if err := rows.Scan(
			&i.ChefID,
			&i.Name,
			&i.ImageUrl,
			&i.NumFollower,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChef = `-- name: UpdateChef :one
SELECT
    id,
    name,
    image_url,
    profile,
    link,
    created_at,
    updated_at,
    num_recipe,
    num_follower
FROM
    update_chef($1, $2)
`

type UpdateChefParams struct {
	ID   pgtype.UUID `json:"id"`
	Data []byte      `json:"data"`
}

type UpdateChefRow struct {
	ID          pgtype.UUID          `json:"id"`
	Name        string               `json:"name"`
	ImageUrl    pgtype.Text          `json:"imageUrl"`
	Profile     pgtype.Text          `json:"profile"`
	Link        dto.ChefLinkArrayDto `json:"link"`
	CreatedAt   pgtype.Timestamptz   `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz   `json:"updatedAt"`
	NumRecipe   int32                `json:"numRecipe"`
	NumFollower int32                `json:"numFollower"`
}

func (q *Queries) UpdateChef(ctx context.Context, arg UpdateChefParams) (UpdateChefRow, error) {
	row := q.db.QueryRow(ctx, updateChef, arg.ID, arg.Data)
	var i UpdateChefRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ImageUrl,
		&i.Profile,
		&i.Link,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumRecipe,
		&i.NumFollower,
	)
	return i, err
}
