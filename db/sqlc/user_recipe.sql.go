// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: user_recipe.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUserRecipe = `-- name: DeleteUserRecipe :one
DELETE FROM
    recipe
WHERE
    usr_id = $1
AND
    id = $2
RETURNING
    id,
    chef_id,
    usr_id,
    name,
    servings,
    image_url,
    introduction,
    link,
    access_level,
    created_at,
    updated_at,
    num_fav
`

type DeleteUserRecipeParams struct {
	UsrID pgtype.UUID `json:"usrId"`
	ID    pgtype.UUID `json:"id"`
}

type DeleteUserRecipeRow struct {
	ID           pgtype.UUID        `json:"id"`
	ChefID       pgtype.UUID        `json:"chefId"`
	UsrID        pgtype.UUID        `json:"usrId"`
	Name         string             `json:"name"`
	Servings     int32              `json:"servings"`
	ImageUrl     pgtype.Text        `json:"imageUrl"`
	Introduction pgtype.Text        `json:"introduction"`
	Link         []string           `json:"link"`
	AccessLevel  int32              `json:"accessLevel"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	NumFav       int32              `json:"numFav"`
}

func (q *Queries) DeleteUserRecipe(ctx context.Context, arg DeleteUserRecipeParams) (DeleteUserRecipeRow, error) {
	row := q.db.QueryRow(ctx, deleteUserRecipe, arg.UsrID, arg.ID)
	var i DeleteUserRecipeRow
	err := row.Scan(
		&i.ID,
		&i.ChefID,
		&i.UsrID,
		&i.Name,
		&i.Servings,
		&i.ImageUrl,
		&i.Introduction,
		&i.Link,
		&i.AccessLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumFav,
	)
	return i, err
}

const getUsrRecipes = `-- name: GetUsrRecipes :many
SELECT
    id, chef_id, usr_id, name, servings, ingredient, method, image_url, introduction, link, access_level, created_at, updated_at, num_fav
FROM
    v_recipe
WHERE
    usr_id = $1
ORDER BY
    created_at DESC
`

func (q *Queries) GetUsrRecipes(ctx context.Context, usrID pgtype.UUID) ([]VRecipe, error) {
	rows, err := q.db.Query(ctx, getUsrRecipes, usrID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VRecipe
	for rows.Next() {
		var i VRecipe
		if err := rows.Scan(
			&i.ID,
			&i.ChefID,
			&i.UsrID,
			&i.Name,
			&i.Servings,
			&i.Ingredient,
			&i.Method,
			&i.ImageUrl,
			&i.Introduction,
			&i.Link,
			&i.AccessLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumFav,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
