// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: recipe.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecipe = `-- name: CreateRecipe :one
SELECT
    id, chef_id, usr_id, name, servings, ingredient, method, image_url, introduction, link, access_level, created_at, updated_at, num_fav
FROM
    insert_recipe($1)
`

func (q *Queries) CreateRecipe(ctx context.Context, data []byte) (VRecipe, error) {
	row := q.db.QueryRow(ctx, createRecipe, data)
	var i VRecipe
	err := row.Scan(
		&i.ID,
		&i.ChefID,
		&i.UsrID,
		&i.Name,
		&i.Servings,
		&i.Ingredient,
		&i.Method,
		&i.ImageUrl,
		&i.Introduction,
		&i.Link,
		&i.AccessLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumFav,
	)
	return i, err
}

const getRecipe = `-- name: GetRecipe :one
SELECT
    id, chef_id, usr_id, name, servings, ingredient, method, image_url, introduction, link, access_level, created_at, updated_at, num_fav
FROM
    v_recipe
WHERE
    id = $1
`

func (q *Queries) GetRecipe(ctx context.Context, id pgtype.UUID) (VRecipe, error) {
	row := q.db.QueryRow(ctx, getRecipe, id)
	var i VRecipe
	err := row.Scan(
		&i.ID,
		&i.ChefID,
		&i.UsrID,
		&i.Name,
		&i.Servings,
		&i.Ingredient,
		&i.Method,
		&i.ImageUrl,
		&i.Introduction,
		&i.Link,
		&i.AccessLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumFav,
	)
	return i, err
}

const listRecipe = `-- name: ListRecipe :many
SELECT
    id,
    chef_id,
    name,
    servings,
    image_url,
    introduction,
    created_at,
    updated_at,
    num_fav
FROM
    recipe
WHERE
    access_level = 1
AND
    chef_id IS NOT NULL
ORDER BY
    num_fav DESC
`

type ListRecipeRow struct {
	ID           pgtype.UUID        `json:"id"`
	ChefID       pgtype.UUID        `json:"chefId"`
	Name         string             `json:"name"`
	Servings     int32              `json:"servings"`
	ImageUrl     pgtype.Text        `json:"imageUrl"`
	Introduction pgtype.Text        `json:"introduction"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	NumFav       int32              `json:"numFav"`
}

func (q *Queries) ListRecipe(ctx context.Context) ([]ListRecipeRow, error) {
	rows, err := q.db.Query(ctx, listRecipe)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecipeRow
	for rows.Next() {
		var i ListRecipeRow
		if err := rows.Scan(
			&i.ID,
			&i.ChefID,
			&i.Name,
			&i.Servings,
			&i.ImageUrl,
			&i.Introduction,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumFav,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrendRecipe = `-- name: ListTrendRecipe :many
WITH
history AS (
    SELECT
        SUM(CASE WHEN is_fav THEN 1 ELSE 0 END) - SUM(CASE WHEN is_fav THEN 0 ELSE 1 END) AS score,
        recipe_id
    FROM
        fav_history
    WHERE
        CURRENT_TIMESTAMP - INTERVAL '3 days' <= created_at
    GROUP BY
        recipe_id
)
SELECT
    history.recipe_id,
    recipe.name,
    recipe.introduction,
    recipe.image_url,
    recipe.num_fav,
    history.score
FROM
    history
INNER JOIN
    recipe
ON
    recipe.access_level = 1
AND
    recipe.chef_id IS NOT NULL
AND
    history.recipe_id = recipe.id
ORDER BY
    score DESC
LIMIT $1
`

type ListTrendRecipeRow struct {
	RecipeID     pgtype.UUID `json:"recipeId"`
	Name         string      `json:"name"`
	Introduction pgtype.Text `json:"introduction"`
	ImageUrl     pgtype.Text `json:"imageUrl"`
	NumFav       int32       `json:"numFav"`
	Score        int32       `json:"score"`
}

func (q *Queries) ListTrendRecipe(ctx context.Context, lim int32) ([]ListTrendRecipeRow, error) {
	rows, err := q.db.Query(ctx, listTrendRecipe, lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTrendRecipeRow
	for rows.Next() {
		var i ListTrendRecipeRow
		if err := rows.Scan(
			&i.RecipeID,
			&i.Name,
			&i.Introduction,
			&i.ImageUrl,
			&i.NumFav,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipe = `-- name: UpdateRecipe :one
SELECT
    id, chef_id, usr_id, name, servings, ingredient, method, image_url, introduction, link, access_level, created_at, updated_at, num_fav
FROM
    update_recipe($1, $2)
`

type UpdateRecipeParams struct {
	ID   pgtype.UUID `json:"id"`
	Data []byte      `json:"data"`
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) (VRecipe, error) {
	row := q.db.QueryRow(ctx, updateRecipe, arg.ID, arg.Data)
	var i VRecipe
	err := row.Scan(
		&i.ID,
		&i.ChefID,
		&i.UsrID,
		&i.Name,
		&i.Servings,
		&i.Ingredient,
		&i.Method,
		&i.ImageUrl,
		&i.Introduction,
		&i.Link,
		&i.AccessLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumFav,
	)
	return i, err
}
