// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: chef_recipe.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteChefRecipe = `-- name: DeleteChefRecipe :one
DELETE FROM
    recipe
WHERE
    id = $1
RETURNING
    id,
    chef_id,
    usr_id,
    name,
    servings,
    image_url,
    introduction,
    link,
    access_level,
    created_at,
    updated_at,
    num_fav
`

type DeleteChefRecipeRow struct {
	ID           pgtype.UUID        `json:"id"`
	ChefID       pgtype.UUID        `json:"chefId"`
	UsrID        pgtype.UUID        `json:"usrId"`
	Name         string             `json:"name"`
	Servings     int32              `json:"servings"`
	ImageUrl     pgtype.Text        `json:"imageUrl"`
	Introduction pgtype.Text        `json:"introduction"`
	Link         []string           `json:"link"`
	AccessLevel  int32              `json:"accessLevel"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	NumFav       int32              `json:"numFav"`
}

func (q *Queries) DeleteChefRecipe(ctx context.Context, id pgtype.UUID) (DeleteChefRecipeRow, error) {
	row := q.db.QueryRow(ctx, deleteChefRecipe, id)
	var i DeleteChefRecipeRow
	err := row.Scan(
		&i.ID,
		&i.ChefID,
		&i.UsrID,
		&i.Name,
		&i.Servings,
		&i.ImageUrl,
		&i.Introduction,
		&i.Link,
		&i.AccessLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumFav,
	)
	return i, err
}

const listChefRecipeFav = `-- name: ListChefRecipeFav :many
SELECT
    id,
    chef_id,
    name,
    servings,
    image_url,
    introduction,
    created_at,
    updated_at,
    num_fav
FROM
    recipe
WHERE
    access_level = 1
AND
    chef_id = $1
ORDER BY
    num_fav DESC
`

type ListChefRecipeFavRow struct {
	ID           pgtype.UUID        `json:"id"`
	ChefID       pgtype.UUID        `json:"chefId"`
	Name         string             `json:"name"`
	Servings     int32              `json:"servings"`
	ImageUrl     pgtype.Text        `json:"imageUrl"`
	Introduction pgtype.Text        `json:"introduction"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	NumFav       int32              `json:"numFav"`
}

func (q *Queries) ListChefRecipeFav(ctx context.Context, chefID pgtype.UUID) ([]ListChefRecipeFavRow, error) {
	rows, err := q.db.Query(ctx, listChefRecipeFav, chefID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChefRecipeFavRow
	for rows.Next() {
		var i ListChefRecipeFavRow
		if err := rows.Scan(
			&i.ID,
			&i.ChefID,
			&i.Name,
			&i.Servings,
			&i.ImageUrl,
			&i.Introduction,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumFav,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChefRecipeNew = `-- name: ListChefRecipeNew :many
SELECT
    id,
    chef_id,
    name,
    servings,
    image_url,
    introduction,
    created_at,
    updated_at,
    num_fav
FROM
    recipe
WHERE
    access_level = 1
AND
    chef_id = $1
ORDER BY
    created_at DESC
`

type ListChefRecipeNewRow struct {
	ID           pgtype.UUID        `json:"id"`
	ChefID       pgtype.UUID        `json:"chefId"`
	Name         string             `json:"name"`
	Servings     int32              `json:"servings"`
	ImageUrl     pgtype.Text        `json:"imageUrl"`
	Introduction pgtype.Text        `json:"introduction"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	NumFav       int32              `json:"numFav"`
}

func (q *Queries) ListChefRecipeNew(ctx context.Context, chefID pgtype.UUID) ([]ListChefRecipeNewRow, error) {
	rows, err := q.db.Query(ctx, listChefRecipeNew, chefID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChefRecipeNewRow
	for rows.Next() {
		var i ListChefRecipeNewRow
		if err := rows.Scan(
			&i.ID,
			&i.ChefID,
			&i.Name,
			&i.Servings,
			&i.ImageUrl,
			&i.Introduction,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumFav,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchChefRecipe = `-- name: SearchChefRecipe :many
SELECT
    id,
    chef_id,
    name,
    servings,
    image_url,
    introduction,
    access_level,
    created_at,
    updated_at,
    num_fav
FROM
    recipe
WHERE
    access_level = 1
AND
    chef_id IS NOT NULL
AND (
    name &@~ $1
OR
    introduction &@~ $1
)
ORDER BY
    pgroonga_score(tableoid, ctid) DESC,
    num_fav DESC
`

type SearchChefRecipeRow struct {
	ID           pgtype.UUID        `json:"id"`
	ChefID       pgtype.UUID        `json:"chefId"`
	Name         string             `json:"name"`
	Servings     int32              `json:"servings"`
	ImageUrl     pgtype.Text        `json:"imageUrl"`
	Introduction pgtype.Text        `json:"introduction"`
	AccessLevel  int32              `json:"accessLevel"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	NumFav       int32              `json:"numFav"`
}

func (q *Queries) SearchChefRecipe(ctx context.Context, query string) ([]SearchChefRecipeRow, error) {
	rows, err := q.db.Query(ctx, searchChefRecipe, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchChefRecipeRow
	for rows.Next() {
		var i SearchChefRecipeRow
		if err := rows.Scan(
			&i.ID,
			&i.ChefID,
			&i.Name,
			&i.Servings,
			&i.ImageUrl,
			&i.Introduction,
			&i.AccessLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NumFav,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
