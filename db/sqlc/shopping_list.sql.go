// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: shopping_list.sql

package db

import (
	"context"

	dto "github.com/aopontann/gin-sqlc/db/dto"
	"github.com/jackc/pgx/v5/pgtype"
)

const createShoppingItem = `-- name: CreateShoppingItem :one
INSERT INTO shopping_item (
    shopping_list_id,
    ingredient_id,
    idx,
    name,
    supplement
)
VALUES
(
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING
    id,
    ingredient_id,
    name,
    supplement,
    created_at,
    updated_at
`

type CreateShoppingItemParams struct {
	ShoppingListID pgtype.UUID `json:"shoppingListId"`
	IngredientID   pgtype.UUID `json:"ingredientId"`
	Idx            int32       `json:"idx"`
	Name           string      `json:"name"`
	Supplement     pgtype.Text `json:"supplement"`
}

type CreateShoppingItemRow struct {
	ID           pgtype.UUID        `json:"id"`
	IngredientID pgtype.UUID        `json:"ingredientId"`
	Name         string             `json:"name"`
	Supplement   pgtype.Text        `json:"supplement"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
}

func (q *Queries) CreateShoppingItem(ctx context.Context, arg CreateShoppingItemParams) (CreateShoppingItemRow, error) {
	row := q.db.QueryRow(ctx, createShoppingItem,
		arg.ShoppingListID,
		arg.IngredientID,
		arg.Idx,
		arg.Name,
		arg.Supplement,
	)
	var i CreateShoppingItemRow
	err := row.Scan(
		&i.ID,
		&i.IngredientID,
		&i.Name,
		&i.Supplement,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createShoppingList = `-- name: CreateShoppingList :one
INSERT INTO shopping_list (
    usr_id,
    recipe_id,
    r_idx,
    description,
    is_fair_copy
)
VALUES
(
    $1,
    $2,
    (SELECT
        COALESCE(MAX(r_idx), 1)
    FROM
        shopping_list
    WHERE
        usr_id = $1
    AND
        recipe_id = $2
    ),
    $3,
    $4
)
RETURNING
    id,
    usr_id,
    recipe_id,
    description,
    is_fair_copy,
    created_at,
    updated_at
`

type CreateShoppingListParams struct {
	UsrID       pgtype.UUID `json:"usrId"`
	RecipeID    pgtype.UUID `json:"recipeId"`
	Description pgtype.Text `json:"description"`
	IsFairCopy  bool        `json:"isFairCopy"`
}

type CreateShoppingListRow struct {
	ID          pgtype.UUID        `json:"id"`
	UsrID       pgtype.UUID        `json:"usrId"`
	RecipeID    pgtype.UUID        `json:"recipeId"`
	Description pgtype.Text        `json:"description"`
	IsFairCopy  bool               `json:"isFairCopy"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
}

func (q *Queries) CreateShoppingList(ctx context.Context, arg CreateShoppingListParams) (CreateShoppingListRow, error) {
	row := q.db.QueryRow(ctx, createShoppingList,
		arg.UsrID,
		arg.RecipeID,
		arg.Description,
		arg.IsFairCopy,
	)
	var i CreateShoppingListRow
	err := row.Scan(
		&i.ID,
		&i.UsrID,
		&i.RecipeID,
		&i.Description,
		&i.IsFairCopy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteNotAnyShoppingItem = `-- name: DeleteNotAnyShoppingItem :exec
DELETE FROM
    shopping_item
WHERE
    shopping_list_id = $1
AND
    NOT (id = ANY ($2::UUID[]))
`

type DeleteNotAnyShoppingItemParams struct {
	ShoppingListID pgtype.UUID   `json:"shoppingListId"`
	ID             []pgtype.UUID `json:"id"`
}

func (q *Queries) DeleteNotAnyShoppingItem(ctx context.Context, arg DeleteNotAnyShoppingItemParams) error {
	_, err := q.db.Exec(ctx, deleteNotAnyShoppingItem, arg.ShoppingListID, arg.ID)
	return err
}

const getShoppingList = `-- name: GetShoppingList :one
SELECT
    id,
    usr_id,
    recipe_id,
    recipe_name,
    chef_name,
    general_chef_name,
    description,
    is_fair_copy,
    created_at,
    updated_at,
    item
FROM
    v_shopping_list
WHERE
    usr_id = $1
AND
    recipe_id = $2
`

type GetShoppingListParams struct {
	UsrID    pgtype.UUID `json:"usrId"`
	RecipeID pgtype.UUID `json:"recipeId"`
}

type GetShoppingListRow struct {
	ID              pgtype.UUID              `json:"id"`
	UsrID           pgtype.UUID              `json:"usrId"`
	RecipeID        pgtype.UUID              `json:"recipeId"`
	RecipeName      string                   `json:"recipeName"`
	ChefName        pgtype.Text              `json:"chefName"`
	GeneralChefName pgtype.Text              `json:"generalChefName"`
	Description     pgtype.Text              `json:"description"`
	IsFairCopy      bool                     `json:"isFairCopy"`
	CreatedAt       pgtype.Timestamptz       `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz       `json:"updatedAt"`
	Item            dto.ShoppingItemArrayDto `json:"item"`
}

func (q *Queries) GetShoppingList(ctx context.Context, arg GetShoppingListParams) (GetShoppingListRow, error) {
	row := q.db.QueryRow(ctx, getShoppingList, arg.UsrID, arg.RecipeID)
	var i GetShoppingListRow
	err := row.Scan(
		&i.ID,
		&i.UsrID,
		&i.RecipeID,
		&i.RecipeName,
		&i.ChefName,
		&i.GeneralChefName,
		&i.Description,
		&i.IsFairCopy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Item,
	)
	return i, err
}

const listShoppingList = `-- name: ListShoppingList :many
SELECT
    id,
    usr_id,
    recipe_id,
    recipe_name,
    chef_name,
    general_chef_name,
    description,
    is_fair_copy,
    created_at,
    updated_at,
    item
FROM
    v_shopping_list
WHERE
    usr_id = $1
ORDER BY
    r_idx DESC
`

type ListShoppingListRow struct {
	ID              pgtype.UUID              `json:"id"`
	UsrID           pgtype.UUID              `json:"usrId"`
	RecipeID        pgtype.UUID              `json:"recipeId"`
	RecipeName      string                   `json:"recipeName"`
	ChefName        pgtype.Text              `json:"chefName"`
	GeneralChefName pgtype.Text              `json:"generalChefName"`
	Description     pgtype.Text              `json:"description"`
	IsFairCopy      bool                     `json:"isFairCopy"`
	CreatedAt       pgtype.Timestamptz       `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz       `json:"updatedAt"`
	Item            dto.ShoppingItemArrayDto `json:"item"`
}

func (q *Queries) ListShoppingList(ctx context.Context, usrID pgtype.UUID) ([]ListShoppingListRow, error) {
	rows, err := q.db.Query(ctx, listShoppingList, usrID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShoppingListRow
	for rows.Next() {
		var i ListShoppingListRow
		if err := rows.Scan(
			&i.ID,
			&i.UsrID,
			&i.RecipeID,
			&i.RecipeName,
			&i.ChefName,
			&i.GeneralChefName,
			&i.Description,
			&i.IsFairCopy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Item,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShoppingItem = `-- name: UpdateShoppingItem :one
UPDATE shopping_item SET
    shopping_list_id = $1,
    ingredient_id    = $2,
    idx              = $3,
    name             = $4,
    supplement       = $5
WHERE
    id = $6
RETURNING
    id,
    ingredient_id,
    name,
    supplement,
    created_at,
    updated_at
`

type UpdateShoppingItemParams struct {
	ShoppingListID pgtype.UUID `json:"shoppingListId"`
	IngredientID   pgtype.UUID `json:"ingredientId"`
	Idx            int32       `json:"idx"`
	Name           string      `json:"name"`
	Supplement     pgtype.Text `json:"supplement"`
	ID             pgtype.UUID `json:"id"`
}

type UpdateShoppingItemRow struct {
	ID           pgtype.UUID        `json:"id"`
	IngredientID pgtype.UUID        `json:"ingredientId"`
	Name         string             `json:"name"`
	Supplement   pgtype.Text        `json:"supplement"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
}

func (q *Queries) UpdateShoppingItem(ctx context.Context, arg UpdateShoppingItemParams) (UpdateShoppingItemRow, error) {
	row := q.db.QueryRow(ctx, updateShoppingItem,
		arg.ShoppingListID,
		arg.IngredientID,
		arg.Idx,
		arg.Name,
		arg.Supplement,
		arg.ID,
	)
	var i UpdateShoppingItemRow
	err := row.Scan(
		&i.ID,
		&i.IngredientID,
		&i.Name,
		&i.Supplement,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateShoppingList = `-- name: UpdateShoppingList :one
UPDATE shopping_list SET
    r_idx        = $1,
    description  = $2,
    is_fair_copy = $3
WHERE
    id = $4
RETURNING
    id,
    usr_id,
    recipe_id,
    description,
    is_fair_copy,
    created_at,
    updated_at
`

type UpdateShoppingListParams struct {
	RIdx        int32       `json:"rIdx"`
	Description pgtype.Text `json:"description"`
	IsFairCopy  bool        `json:"isFairCopy"`
	ID          pgtype.UUID `json:"id"`
}

type UpdateShoppingListRow struct {
	ID          pgtype.UUID        `json:"id"`
	UsrID       pgtype.UUID        `json:"usrId"`
	RecipeID    pgtype.UUID        `json:"recipeId"`
	Description pgtype.Text        `json:"description"`
	IsFairCopy  bool               `json:"isFairCopy"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
}

func (q *Queries) UpdateShoppingList(ctx context.Context, arg UpdateShoppingListParams) (UpdateShoppingListRow, error) {
	row := q.db.QueryRow(ctx, updateShoppingList,
		arg.RIdx,
		arg.Description,
		arg.IsFairCopy,
		arg.ID,
	)
	var i UpdateShoppingListRow
	err := row.Scan(
		&i.ID,
		&i.UsrID,
		&i.RecipeID,
		&i.Description,
		&i.IsFairCopy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
